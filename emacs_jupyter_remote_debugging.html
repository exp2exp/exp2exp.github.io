<html><html><head><meta charset="UTF-8" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><link href="https://exp2exp.github.io/static/css/firn_base.css" rel="stylesheet" /></head></html><body><main><article class="content"><h1>emacs-jupyter remote debugging</h1><div><div><section></section><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="debugging"><span class="firn-headline-text"><span>Debugging</span></span></h1><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="initial-fix-(of-what-turned-out-to-be-a-minor-problem)"><span class="firn-headline-text"><span>Initial fix (of what turned out to be a minor problem)</span></span></h2><section><ul><li><p><code>jupyter-start-kernel</code><span> was problematic, because the id didn’t seem to be set correctly</span></p><ul><li><p><span>line -2 from end of this function, added </span><code>:id (substring conn-file -41 -5)</code><span>.</span></p></li></ul></li></ul></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="ongoing-concerns:-can-we-access-the-kernel?"><span class="firn-headline-text"><span>Ongoing concerns: can we access the kernel?</span></span></h2><section><ul><li><p><span>However, this still doesn’t solve our problem</span></p><ul><li><p><span>Now we are debugging </span><code>jupyter-kernel-info</code></p></li><li><p><span>Our aim is to figure out </span><code>jupyter-send-kernel-info-request</code><span>, maybe also </span><code>jupyter-wait-until-received</code></p></li></ul></li><li><p><span>jupyter-comm-initialize</span></p></li><li><p><span>jupyter-kernel-info</span></p></li><li><p><span>jupyter-make-client</span></p></li><li><p><span>jupyter-session —</span></p></li><li><p><span>jupyter-kernel-info — doesn’t get a message back for some reason</span></p></li></ul><p><span>We suspect it looks at the wrong kernel b/c it examines an id that
doesn’t seem to exist on the server.</span></p><pre class="language-elisp"><code class="language-elisp">(with-slots (kernel) manager
  (oref kernel session))
</code></pre></section></div></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="set-up-container-on-gcp"><span class="firn-headline-text"><span>Set up container on gcp</span></span></h1><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="gcp-configuration"><span class="firn-headline-text"><span>gcp configuration</span></span></h2><section><p><span>You may like to run </span><code>gcloud auth login</code><span> ( </span><a class="firn-external" href="https://cloud.google.com/sdk/gcloud/reference/auth/login" target="_blank">auth login docs</a><span> ). This is an interactive process that launches oauth for your google account in the web browser so I think it is best to do it from a terminal though it may be possible to run it in org-babel.</span></p><pre class="language-sh"><code class="language-sh">gcloud config configurations list
</code></pre><pre class="language-sh"><code class="language-sh">gcloud config configurations describe quarere
</code></pre></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="launch-container-image"><span class="firn-headline-text"><span>launch container image</span></span></h2><section><p><span>Deploy a vm based on the container </span><code>cameronraysmith/notebooks:latest</code><span>.</span></p><pre class="language-sh"><code class="language-sh">gcloud compute instances create-with-container notebooks-vm \
    --container-image registry.hub.docker.com/cameronraysmith/notebooks:latest \
    --container-restart-policy on-failure \
    --container-privileged \
    --container-stdin \
    --container-tty \
    --container-mount-host-path mount-path=/home/jupyter,host-path=/tmp,mode=rw \
    --machine-type n1-standard-1 \
    --boot-disk-size 50GB \
    --preemptible
</code></pre><p><span>Setup ssh with your new instance</span></p><pre class="language-sh"><code class="language-sh">gcloud compute config-ssh
cat ~/.ssh/config | grep "Host notebooks"
</code></pre><p><span>You can </span><code>ssh</code><span> into the host machine or the container using the various commands below.</span></p><p><span>Of course you can stop and start the machine with</span></p></section></div></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="startup-the-cloud-vm-running-our-container-of-interest"><span class="firn-headline-text"><span>Startup the cloud vm running our container of interest</span></span></h1><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="setup-remote-container-host-machine"><span class="firn-headline-text"><span>Setup remote container host machine</span></span></h2><section><p><span>We already setup the container named </span><code>notebooks-vm</code><span> so all we need to do to begin with is to start it up.</span></p><pre class="language-sh"><code class="language-sh">gcloud compute instances start notebooks-vm
</code></pre><p><span>Check that our instance is indeed running</span></p><pre class="language-sh"><code class="language-sh">gcloud compute instances list
</code></pre><p><span>Make sure the correct ip address is entered into our </span><code>.ssh/config</code><span> file.</span></p><pre class="language-sh"><code class="language-sh">gcloud compute config-ssh
</code></pre><p><span>Inspect the IP address we find in our </span><code>.ssh/config</code><span> file</span></p><pre class="language-sh"><code class="language-sh">grep HostName ~/.ssh/config
</code></pre></section><div class="firn-headline-section firn-headline-section-3"><h3 class="firn-headline firn-headline-3" id="execute-commands-on-the-remote-container-host-machine"><span class="firn-headline-text"><span>Execute commands on the remote container host machine</span></span></h3><section><pre class="language-sh"><code class="language-sh">hostname --long
</code></pre><pre class="language-sh"><code class="language-sh">docker container ls
</code></pre><pre class="language-sh"><code class="language-sh">docker container ls
</code></pre></section></div></div></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="run-shell-commands-on-the-remote-container"><span class="firn-headline-text"><span>Run shell commands on the remote container</span></span></h1><section><p><span>To switch between two available configurations, choose one of the lines below to copy to the </span><code>:PROPERTIES:</code><span> drawer for this section.</span></p><p><span>In order to connect to the remote host followed by the docker container we specify the directory as </span><code>ssh:notebooks-vm</code><span> (including the extra details we got from </span><code>gcloud compute ssh-config</code><span>) followed by </span><code>docker:containername</code><span> where we got the container name from running </span><code>docker container ls</code><span> on the remote machine.</span></p><pre class="language-sh"><code class="language-sh">echo $JUPYTER_PATH
</code></pre><pre class="language-sh"><code class="language-sh">head -3 /proc/self/cgroup
</code></pre><p><span>Check the working directory and the list of jupyter kernels</span></p><pre class="language-sh"><code class="language-sh">echo $JUPYTER_PATH
</code></pre><pre class="language-sh"><code class="language-sh">jupyter kernelspec list
</code></pre><p><span>If you try to make use of an existing session on the docker container to run one of the </span><code>emacs-jupyter</code><span> kernels, you find that there is a different usage of the TRAMP remote path specification in the </span><code>:dir</code><span> property for the </span><code>sh</code><span> language of babel and with the </span><code>:session</code><span> property in the </span><code>emacs-jupyter</code><span> </span><em><span>language</span></em><span> of babel. This is the error I got the first time I tried this with the TRAMP remote path specification in </span><code>:dir</code><span>:</span></p></section><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="run-python-session-on-the-remote-container"><span class="firn-headline-text"><span>Run python session on the remote container</span></span></h2><section><p><span>The default properties that should apply to this section are</span></p><p><span>In order to connect to the remote host followed by the docker container we specify the directory as </span><code>ssh:notebooks-vm</code><span> (including the extra details we got from </span><code>gcloud compute ssh-config</code><span>) followed by a </span><code>|</code><span> and then </span><code>docker:containername</code><span> where we got the container name from running </span><code>docker container ls</code><span> on the remote machine.</span></p><pre class="language-python"><code class="language-python">x = 'foo'
y = 'bar'
print(x + ' ' + y)
</code></pre><pre class="language-python"><code class="language-python">x = 1 + 1
print(x)
</code></pre></section></div></div></div></div><div><hr /><div class="backlinks"><h4>Backlinks to this document:</h4><ul class="firn-backlinks"><li class="firn-backlink"><a href="https://exp2exp.github.io/index">index</a></li><li class="firn-backlink"><a href="https://exp2exp.github.io/20200905125342-emacs_hyper_notebook">Emacs Hyper Notebook</a></li></ul></div></div></article></main></body></html>