:PROPERTIES:
:ID:       a860f0d4-bb54-43ab-98fb-0f49a3431722
:END:
#+TITLE: 06 February 2021 — Emacs Research Group
#+Author: Noorah Alhasan, Joe Corneli, David O’Toole, Raymond Puzio, Cameron Ray Smith, Leo Vivier with special guest Qiantan Hong
#+roam_tag: HI
#+FIRN_UNDER: erg
#+FIRN_LAYOUT: erg-update
#+DATE_CREATED: <2021-02-06 Saturday>

In this meeting we did a live demo and source code
exploration of [[https://code.librehq.com/qhong/crdt.el][crdt.el]] with the author, Qiantan Hong.
In the last 15 minutes we outlined some plans for the next meeting, to
focus on Patterns + Org mode.

* High level overview

- Different levels of correctness
- Sharing multiple buffers
- Buffers are synchronised naïvely
* The algorithm
** User synchronisation algorithm
*** ‘Each writer wants to see their change instantly.’
*** Authority → Inter-related with others’s
**** Problem: It will wait for a round-trip.
** Original transform: Broadcasting one’s operations naïvely
*** Synchronising text-first
*** Fundamental problem
*** Person A: Type ‘a’ at position 100; the character appears
*** Person B: Type ‘b’ at position 90; there’s going to be an offset for Person A.
** Operation transform
*** Relating the different operations between the different
*** Working with proprieties
*** Working with IDs to every change, and requiring those IDs (unambiguous labels?)
*** The IDs need to be strictly incremental
**** Q: Linearity of the changes?
*** Because you’re never using the absolute position (hence, everything is relative)
*** ‘Every character, every operation, after it has been created, is a persistent data, associated with a unique label (i.e. the time at which it was created)’
** On the question of conflicts
*** Ray: Are there possible conflicts when two users decide to act on the same portion of a buffer?
**** Example
***** ‘AB’
***** ‘ABC’ vs. ‘ABD’
*** L: Is the time-keeping done by the server or the client (to avoid clashes)?
**** J: The resolution is not done merely on time, but on the identification of users.
**** ‘The server does not play a significant rôle in that operation, other than broadcasting messages’
***** ‘The ID is generated by the client; the server is just the broadcaster.’
***** ‘There’s no strict notion of “earlier”.’
**** Using random IDs would lead to problem with interleaving the changes
**** ‘Instead of generating an ID for every change, crdt is generating an idea for a /segment/ of text’
***** The result of the previous example would be ‘ABCD’ or ‘ABDC’.
**** The chunking is handled by related IDs, i.e., in ‘CAT’, ‘A’ would be related to ‘C’, etc.
** Implementation questions
*** Text-properties
**** All the
* JC: Some detailed comments on the code
(To some extent this replicates the above; Leo and Joe were typing in different buffers.)
** Background

Qiantan: was doing a music project and wanted something like this.
Older packages didn’t really work or used naive algorithms.
** Usage

- To share a buffer: M-x crdt-share-buffer
- Collaborative editing: each writer wants to see the changes instantly
- Classical sync mode, there’s a central authority that keeps everything in a linear order
- But this has problems in that it’s slow.
** Comparison with OT
- Historically, the OT algorithm deals with difficulties
- E.g., "insert a character ’a’ at position 100"
- If everyone does this it seems to work... But this doesn’t really work.
- What if someone else "insert a character ’b’ at position 90"
** How it works

- Now, require the id to be strictly increasing
- A B C, each with id 1 2 3
- A B D C results from "insert D with id 2.5".
- You never use the absolute position.  Everyone will receive the correctly ordered info.
- The question is, what if you keep working?  The labels need to keep syncronized.
- Are there any cases where it can desynchronise later?
- The invariant is that after the data is created, it always keeps the same label.
- There’s a question of "which labels can I refer to?" — possible conflicts between different editors...?
- Each client/site has a unique id attached to themselves.  Instead of inserting between 2.50, 2.51, 2.53 — this extra bit is assigned to the clients

What about:

- A B, C? D? — Actually, either "A C D B" or "A D C B" could make sense.
- Both come simultaneously, do I put C or D first... later I put a C and D first
- The ids are generated per user.  The server doesn’t play any central role.
- The only thing the server does is to broadcast messages.

How to deal with insert of regions/strings?

- But this does raise a problem to the original CRDT algorithm.  A B — A (C D)_1  A (E F)_2 B
- You could get "A C E D F B" from the original algorithm.  So, instead of adding ids for characters, use
- an identifier for the region of text rather than the individual characters.
** Logging/warnings
- =(warn "test")=
- You can log the traffic to *Messages*
- But it gets huge. — Maybe can broadcast some of the key things to warnings?
** The core algorithm

- CRDT IDs are represented by _unibyte strings_ (for efficient comparison)
- ‘lsh’ bits shifted left by count
- comparing ids in lexicographic order happens a lot
- Encoding with bigendian unibyte strings can use string=, string< to do the comparison
- reading & writing two-byte integers into this representation
** How to get the ID of the site

- this one generates the unique ID between two other ids
- low-offset is a position within the segment
- a CAT b, will generate a text property for CAT — C will have the id, A will have id+1, T id+2
- use one text property for a continuous range of text
- There are a bunch of Haskell people who also do live coding!
- Lisp is better for creative coding :-)
- The Haskell people use Electro to run their code — and it’s important for them to know who created some code
** The main data structure
-  There’s a table of CRDT sessions, mapping them to this structure
** Network traffic, parsing messanges
- This doesn’t really connect but it’s how it handles network traffic
- The parsing in here isn’t particularly efficient
- This can have bottlenecks...
- There is also an ability to log events
- If there are errors happening, it would make sense
- to display things like stop the session.

* Paths of improvement?
** Colour-coded modifications
*** Maybe a bg face?
** Adding extra hooks
*** ~crdt--user-menu-goto~
** Making click in ~crdt-user-menu-mode~ an alias for <Enter>           :easy:
*** Easy PR
** Max number of users
*** Currently 2 to 16 concurrent users
*** Noorah recommends keeping it under 10 for situations
** Getting inspiration from etherpad wrt algorithm, number of concurrent users, etc.
** [#B] Stopping the session is not necessarily reliable
*** There are some required checks to prevent data-lossage
*** ‘You have to use ~crdt-stop-session~ vs. ~crdt-disconnect~.’
** Using ~warn~ to show disconnection warning                           :easy:
*** Otherwise, it’s too subtle to be noticed
*** ‘Using messages are hard to notice, but it is my personal opinion that is easy to notice’
*** ~Synchronization error detected, try recovering...~
** Problem when switching major-mode: crdt is reset                   :easy:
*** Using a local-var is not possible because the env is dropped when reloading the major-mode
*** Using a global-var
* Other comments
** Qiantan writes very interesting comment in their packages.
** Nice point on Haskell vs. Elisp when designing programs/algorithms, especially taking into account
** David might be interested in getting in touch with Qiantan based on his work on music
** Our org-mode buffer was doomed, but we managed to fix
** Qiantan doesn’t really take notes
* Questions on the future of crdt.el
** Do you plan on merging this into Emacs’s core?
*** Response
QH: I don’t make plans :-)
There are boring issues with copyright assignment, but MIT .
But I am graduating this summer
*** /CLA/ ? might be a problem because of MIT. (Copyright Licence Agreement, historically made against MIT)
*** MELPA?
** Can we help to work on UX & development?
We’d be quite excited to keep working on this as a population of testers
and as potential helpers with the code.
LV has no experience with this algorithm...
LV Would be excited to work with the UX of the program.
*** What would be necessary to facilitate the development of crdt.el?
**** UX might be an easy thing to address
**** Iterating on the code
***** Qiantan is happy to explain some of the code to us.
**** Documentation
**** Organising a hackathon for improving crdt.el?
***** Qiantan works very efficiently when they’re alone; however, they’d be happy to help.
* PAR (Project Action Report/Review)
** 1. Review the intention: what do we expect to learn or make together?
**** Qiantan as special guest to describe and demo crdt
**** Q&A about CRDT
**** This (meeting with Qiantan) is a perfect example of the kind of thing we wanted to do
** 2. Establish what is happening: what and how are we learning?
**** Very successful demo
**** Fun time getting to know Qiantan
** 3. What are some different perspectives on what’s happening?
**** Worked well from Qiantan’s side
**** Qiantan doesn’t use org mode... it generates section
**** We are very excited about crdt
**** Joe took less notes this time
** 4. What did we learn or change?
**** We found a few bugs and possible features
**** We understand the CRDT algorithm and also features of the code (like clicking on users to follow them)
** 5. What else should we change going forward?
**** Leo to liaise UX, dev stuff
**** Nice to have further sessions where we go in depth about code
**** Ideal to have specific questions
**** Email bugs and features
**** Follow up with a demo of the music stuff sometime
**** Follow up with a public session to promote this at some stage
**** Prepare for CRDT Hackathon in summer?
* Next time
** Meeting with Charlie next week [2021-02-13 Sat 18:30-20:30]
*** Exploration of Joe’s org-roam-based-workflow
**** org-roam might be optional for them, since most of them are not by any stretch of the imagination expert Emacs users
***** Could we have the same level of success with a novice, as we did with Qiantan (an expert) today?
****** Could be a nice reflection on our bridging the gap
****** It would also allow us to /harvest/ the design serendipity of other people
**** Functional demo, something à la David with Noorah?
*** Working on patterns
**** Esp. on the virtuous circle of working/PAR/working/PAR/…
**** In the context of Emacs & research
***** We’d be covering new ground: Source for a paper
* Agenda for next time
** Interview on patterns, as a ERG/Peeragogy joint venture
*** COMMENT org (25%)
**** Just present the way we take notes; no need to go into the deep stuff
**** Noorah might be able to present a shortened version of her org setup.
*** COMMENT patterns (75%)
*** Patterns
** Other stuff (45 min)
*** AI & Data analysis
**** Exchange between digital humanities and AI
* Points for later
** Collaborative slip-box
