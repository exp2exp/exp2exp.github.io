#+title: Emacs Hyper Notebook
#+roam_tags: CDN
#+CATEGORY: DEV

We are developing a better way to do “Jupyter notebooks” using Emacs.
This recovers some of the Research Collab ideas developed by Aaron
Krowne. It should integrate features such as writing and task
management (e.g., /Org/) Program evaluation (e.g., /Maxima/),
Typesetting and presentation (e.g., slides via /LaTeX/), and
navigation (e.g., /Org Roam/ for displaying topics as a graph).  We
should be clear that the various technologies used are slot-fillers
and they might be replaced with other things, or augmented (e.g.,
/Lean/ for formal verification of some of the above?). A useful input
to this process would be implementation of examples without
integration.  This can then be redone in a more integrated fashion.

An integration using existing technologies will have limitations, once
we have this demos then we will see some of the gaps and how more
advanced tech could be useful. (For example, Ray’s work with Gerschom
could turn out to be useful here.)

** Some quick thoughts

- If it was sitting inside a web container, then maybe it’s a quickstart thing that comes in a user friendly form.
- Maybe add menu-bar items to make it look like a web browser.
- Emacs Maxima interface, we might build on it — for Monday 12th October, a quick "15 minutes" talk to catch up
- ... possible deliverable for later on: a NIST talk?

* TODO Figure out subtasks to deliver for EmacsConf         :joe:ray:cameron:
* TODO Figure out how EHN relates to other projects         :joe:ray:cameron:
* TODO Keep testing crdt.el and lockstep.el                         :joe:ray:
* TODO Could Emacsconf talk become a blog post?             :joe:ray:cameron:

(Notice that with crdt, typing can go on inside folded nodes! Qiantan
is thinking about a mode to make overlays shareable, which would
change things a bit.)

* Partial prototypes

How far can we go... Through [[https://roamresearch.com/][Roam]]? (We could at least talk to Connor
about Roam on Twitter?) Through [[https://jupyter.org/][Jupyter]]? [[https://foambubble.github.io/foam/][Foam]]? [[https://gtoolkit.com/][Glamorous Toolkit]]?  Can
we integrate what we’re building with existing tools like these?  Do
Lenses or other kinds of ACT machinery help with this at all?  Would
our system potentially play a role as a universal backend?

* Feature: Arxana 2020

Revisit [[https://repo.or.cz/w/arxana.git][Arxana]] and turn it into something that we can actually use.
This is rather closely related to the use of “knowledge graph”
formulations we’ve been discussing, since Arxana allows us to combine
writing with knowledge representations.  In our last round of work
with Arxana, we left off at the point of integrating logic programming
into the system.

* Links to useful resources

Technology like this could be used to build simple demos (e.g., Emacs
in the browser, running Org Mode).  We’ve noticed some other related
tools as well, like [[https://github.com/200ok-ch/organice][Organice]] and [[https://github.com/tecosaur/codiorg][CodiOrg]] that could provide
alternative interfaces.

- [[https://github.com/exp2exp/notebooks][exp2exp/notebooks: This is a Docker configuration for running jupyter with multiple kernels on Arch Linux.]]
- [[https://www.gnu.org/software/emacs/manual/html_node/emacs/emacsclient-Options.html][emacsclient Options - GNU Emacs Manual]]
- [[https://github.com/butlerx/wetty][butlerx/wetty: Terminal in browser over http/https. (Ajaxterm/Anyterm alternative, but much better)]]
- [[https://github.com/xtermjs/xterm.js#real-world-uses][xtermjs/xterm.js: A terminal for the web]]
- [[https://twitter.com/cianbutlerx]]
- [[https://github.com/tsl0922/ttyd][tsl0922/ttyd: Share your terminal over the web]]
- [[https://github.com/yudai/gotty][yudai/gotty: Share your terminal as a web application]]
- [[https://hub.docker.com/r/butlerx/wetty][butlerx/wetty - Docker Hub]]
- [[https://medium.com/@pacroy/setup-web-terminal-using-wetty-docker-image-dcb1ea75bfaf][Setup Web Terminal using Wetty Docker Image | by Chairat Onyaem (Par) | Medium]]
- [[https://hub.docker.com/r/krishnasrinivas/wetty/][krishnasrinivas/wetty - Docker Hub]]

* Other related work

- James Fairbanks (relate this to Betancourt).

* Testing

#+begin_src clojure :session :backend cider :results output org
(def a 2)
#+end_src

#+RESULTS:
#+begin_src org
#'user/a
#+end_src

#+begin_src clojure :session :backend cider :results output org
a
#+end_src

#+RESULTS:
#+begin_src org
2
#+end_src

#+begin_src clojure :session :backend cider :results output org
(range 10)
(def a 1)
#+end_src

#+RESULTS:
#+begin_src org
| (0 1 2 3 4 5 6 7 8 9) |
| #'user/a              |
#+end_src

#+begin_src clojure :session :backend cider :results output org
a
#+end_src

#+RESULTS:
#+begin_src org
1
#+end_src

* What would we actually want as our org interface?

Configuration of the =src= block might look like:

=maxima :process :backend maxima :results output org=

- =:process= stands in for =:session= now as an alternative
- =org-babel-execute-src-block= this is what will be called
- hang into the =lang= parameter of the above function, but override using =:process=

#+begin_src calc :stream calculator :results output org
100*9
#+end_src

#+RESULTS:
#+begin_src org
| value | 900 |
#+end_src

#+begin_src
1+1;

(error "No such language mode: nil-mode")
  signal(error ("No such language mode: nil-mode"))
  error("No such language mode: %s" nil-mode)
  org-edit-src-code()
  org-babel-do-key-sequence-in-edit-buffer("\011")
  (cond ((and (memq type (quote (plain-list item))) (= (line-beginning-position) (org-element-property :post-affiliated element))) nil) ((and (eq type (quote latex-environment)) (>= (point) (org-element-property :post-affiliated element)) (< (point) (let ((--mpom (org-element-property :end element))) (save-excursion (if (markerp --mpom) (progn ...)) (save-excursion (save-restriction ... ... ... ...)))))) nil) ((and (eq type (quote src-block)) org-src-tab-acts-natively (> (line-beginning-position) (org-element-property :post-affiliated element)) (< (line-beginning-position) (let ((--mpom (org-element-property :end element))) (save-excursion (if (markerp --mpom) (progn ...)) (save-excursion (save-restriction ... ... ... ...)))))) (org-babel-do-key-sequence-in-edit-buffer (kbd "TAB"))) (t (let ((column (org--get-expected-indentation element nil))) (if (<= (current-column) (current-indentation)) (indent-line-to column) (save-excursion (indent-line-to column)))) (if (eq type (quote node-property)) (progn (let ((column (current-column))) (org--align-node-property) (org-move-to-column column))))))
  (let* ((element (save-excursion (beginning-of-line) (org-element-at-point))) (type (org-element-type element))) (cond ((and (memq type (quote (plain-list item))) (= (line-beginning-position) (org-element-property :post-affiliated element))) nil) ((and (eq type (quote latex-environment)) (>= (point) (org-element-property :post-affiliated element)) (< (point) (let ((--mpom ...)) (save-excursion (if ... ...) (save-excursion ...))))) nil) ((and (eq type (quote src-block)) org-src-tab-acts-natively (> (line-beginning-position) (org-element-property :post-affiliated element)) (< (line-beginning-position) (let ((--mpom ...)) (save-excursion (if ... ...) (save-excursion ...))))) (org-babel-do-key-sequence-in-edit-buffer (kbd "TAB"))) (t (let ((column (org--get-expected-indentation element nil))) (if (<= (current-column) (current-indentation)) (indent-line-to column) (save-excursion (indent-line-to column)))) (if (eq type (quote node-property)) (progn (let ((column ...)) (org--align-node-property) (org-move-to-column column)))))))
  (if (org-at-heading-p) nil (let* ((element (save-excursion (beginning-of-line) (org-element-at-point))) (type (org-element-type element))) (cond ((and (memq type (quote (plain-list item))) (= (line-beginning-position) (org-element-property :post-affiliated element))) nil) ((and (eq type (quote latex-environment)) (>= (point) (org-element-property :post-affiliated element)) (< (point) (let (...) (save-excursion ... ...)))) nil) ((and (eq type (quote src-block)) org-src-tab-acts-natively (> (line-beginning-position) (org-element-property :post-affiliated element)) (< (line-beginning-position) (let (...) (save-excursion ... ...)))) (org-babel-do-key-sequence-in-edit-buffer (kbd "TAB"))) (t (let ((column (org--get-expected-indentation element nil))) (if (<= (current-column) (current-indentation)) (indent-line-to column) (save-excursion (indent-line-to column)))) (if (eq type (quote node-property)) (progn (let (...) (org--align-node-property) (org-move-to-column column))))))))
  org-indent-line()
  indent-according-to-mode()
  electric-indent-post-self-insert-function()
  self-insert-command(1)
  newline(nil 1)
  (if indent (org-newline-and-indent arg) (newline arg interactive))
  org--newline(nil nil 1)
  (let ((auto-fill-function (and (not (org-at-property-p)) auto-fill-function))) (org--newline indent arg interactive))
  (cond ((or (and (eq (quote table) (org-element-type context)) (not (eq (quote table\.el) (org-element-property :type context))) (>= (point) (org-element-property :contents-begin context)) (< (point) (org-element-property :contents-end context))) (org-element-lineage context (quote (table-row table-cell)) t)) (if (or (looking-at-p "[ \011]*$") (save-excursion (skip-chars-backward " \011") (bolp))) (insert "\n") (org-table-justify-field-maybe) (call-interactively (function org-table-next-row)))) ((and org-return-follows-link (or (and (eq (quote link) (org-element-type context)) (let ((origin ...)) (let (...) (save-excursion ... ...)))) (org-in-regexp org-ts-regexp-both nil t) (org-in-regexp org-tsr-regexp-both nil t) (org-in-regexp org-link-any-re nil t))) (call-interactively (function org-open-at-point))) ((and (not (bolp)) (let ((case-fold-search nil)) (org-match-line org-complex-heading-regexp))) (let ((tags-column (and (match-beginning 5) (save-excursion (goto-char ...) (current-column)))) (string (if (and (match-end 4) (org-point-in-group ... 4)) (progn (delete-and-extract-region ... ...))))) (cond ((not (and tags-column string))) (org-auto-align-tags (org-align-tags)) (t (org--align-tags-here tags-column))) (end-of-line) (org-show-entry) (org--newline indent arg interactive) (if string (progn (save-excursion (insert (org-trim string))))))) ((and (not (eolp)) (org-element-lineage context (quote (item)))) (let ((trailing-data (delete-and-extract-region (point) (line-end-position)))) (org--newline indent arg interactive) (save-excursion (insert trailing-data)))) (t (let ((auto-fill-function (and (not (org-at-property-p)) auto-fill-function))) (org--newline indent arg interactive))))
  (let ((context (if org-return-follows-link (org-element-context) (org-element-at-point)))) (cond ((or (and (eq (quote table) (org-element-type context)) (not (eq (quote table\.el) (org-element-property :type context))) (>= (point) (org-element-property :contents-begin context)) (< (point) (org-element-property :contents-end context))) (org-element-lineage context (quote (table-row table-cell)) t)) (if (or (looking-at-p "[ \011]*$") (save-excursion (skip-chars-backward " \011") (bolp))) (insert "\n") (org-table-justify-field-maybe) (call-interactively (function org-table-next-row)))) ((and org-return-follows-link (or (and (eq (quote link) (org-element-type context)) (let (...) (let ... ...))) (org-in-regexp org-ts-regexp-both nil t) (org-in-regexp org-tsr-regexp-both nil t) (org-in-regexp org-link-any-re nil t))) (call-interactively (function org-open-at-point))) ((and (not (bolp)) (let ((case-fold-search nil)) (org-match-line org-complex-heading-regexp))) (let ((tags-column (and (match-beginning 5) (save-excursion ... ...))) (string (if (and ... ...) (progn ...)))) (cond ((not (and tags-column string))) (org-auto-align-tags (org-align-tags)) (t (org--align-tags-here tags-column))) (end-of-line) (org-show-entry) (org--newline indent arg interactive) (if string (progn (save-excursion (insert ...)))))) ((and (not (eolp)) (org-element-lineage context (quote (item)))) (let ((trailing-data (delete-and-extract-region (point) (line-end-position)))) (org--newline indent arg interactive) (save-excursion (insert trailing-data)))) (t (let ((auto-fill-function (and (not ...) auto-fill-function))) (org--newline indent arg interactive)))))
  org-return(nil nil 1)
  funcall-interactively(org-return nil nil 1)
  call-interactively(org-return nil nil)
  command-execute(org-return)
#+end_src

* Backends
** jupyter
:PROPERTIES:
:ID:       43fd0298-adec-400a-a9b6-6d48cfd244a6
:END:

The jupyter backend works well locally but suffers from a bug when run via tramp. Se [[file:emacs_jupyter_remote_debugging.org][emacs-jupyter remote debugging]] .

* Future work

- Extending to VS Code?  Would people who use VS code even want this kind of interaction?  Maybe VS Code is better for quick visualisations?

* Contributes to                                                   :noexport:
- [[file:20200810135457-visual_interfaces.org][Visual Interfaces]]
- [[file:20200905131918-knowledge_graph.org][Knowledge graph]]
