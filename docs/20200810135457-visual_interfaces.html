<html><html><head><meta charset="UTF-8" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><link href="https://exp2exp.github.io/static/css/firn_base.css" rel="stylesheet" /></head></html><body><main><article class="content"><h1>Visual Interfaces</h1><div><div><section></section><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="graphical-flow-for-programs"><span class="firn-headline-text"><span>Graphical flow for programs</span></span></h1><section><p><span>Can we model more general program flow in a similar fashion to Monocl?</span></p></section></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="limitations"><span class="firn-headline-text"><span>Limitations</span></span></h1><section><p><span>The idea of graphical programming languages is linked with the</span><a class="firn-external" href="https://en.wikipedia.org/wiki/Deutsch_limit" target="_blank">Deutsch limit</a><span> (named for noted programmer </span><a class="firn-external" href="https://en.wikipedia.org/wiki/L._Peter_Deutsch" target="_blank">L Peter Deutsch</a><span>, not
physicist </span><a class="firn-external" href="https://en.wikipedia.org/wiki/David_Deutsch" target="_blank">David Deutsch FRS</a><span>, though perhaps he could come into play later):</span></p><blockquote><p><em><span>The problem with visual programming is that you can’t have more than 50 visual primitives on the screen at the same time.</span></em></p></blockquote></section></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="automatically-create-visual-interfaces"><span class="firn-headline-text"><span>Automatically create visual interfaces</span></span></h1><section><p><span>Here's an idea: assuming we have enough text mining pixie dust (on
corpora of linux man pages, and stack overflow questions/forum posts
about linux commands), it might be possible to do:</span></p><p><code>user:~$ make-gui-for ls --output ls.py</code></p></section></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="feature:-build-infra-for-generating-and-displaying-graphs"><span class="firn-headline-text"><span>Feature: Build infra for generating and displaying graphs.</span></span></h1><section><p><span>E.g., we can generate graphs based on code flow.</span></p><pre><code>(defun triangle (n)
  (if (equal n 0) 0
    (+ n (triangle (- n 1)))))
</code></pre><p><span>This would then be related to the visual code walk through feature described below.</span></p></section></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="feature:-visual-code-walk-through"><span class="firn-headline-text"><span>Feature: Visual code walk through</span></span></h1><section><p><span>Ray is working on a visual code walk through.  This should be seen as
another interface to the same basic underlying information, sort of
like how Org Roam is the main interface to the data served by Org Roam
Server.</span></p></section><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="general-evaluation-strategy-for-these-demos:"><span class="firn-headline-text"><span>General evaluation strategy for these demos:</span></span></h2><section><ul><li><p><em><span>‘Would anyone want to use this?’</span></em></p></li><li><p><span>E.g., in the case of Emacs "learn X in Y" demo.</span></p></li><li><p><span>If there is interest, work up to covering the HtDP book</span></p></li></ul></section></div><div class="firn-headline-section firn-headline-section-2"><h2 class="firn-headline firn-headline-2" id="related-work"><span class="firn-headline-text"><span>Related work</span></span></h2><section><ul><li><p><span>MAUDE framework. :: You describe your programming language using
  rewrite rules in K.  They define tools to auto-derive rules in </span><a class="firn-external" href="http://www.kframework.org/index.php/Projects" target="_blank">K</a><span>.</span></p></li><li><p><span>Program slicing :: ‘Galois connection on the traces’. This allows
  you to find where bugs appeared.  People tend to look in the most
  recent.  Imagine a call-graph of all the variables, so it gives you
  a minimum trace, showing where your bug can be found.</span></p></li></ul></section></div></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="next-steps"><span class="firn-headline-text"><span>Next steps</span></span><span class="firn-org-tags"><span><a class="firn-org-tag" href="/tags#noexport">noexport</a></span></span></h1><section><ul><li><p><a class="firn-internal" href="https://exp2exp.github.io/20200905132603-paperspace_do_nj_etc_collaboratory">Paperspace DO NJ etc. Collaboratory</a></p></li></ul></section></div><div class="firn-headline-section firn-headline-section-1"><h1 class="firn-headline firn-headline-1" id="contributes-to"><span class="firn-headline-text"><span>Contributes to</span></span><span class="firn-org-tags"><span><a class="firn-org-tag" href="/tags#noexport">noexport</a></span></span></h1><section><ul><li><p><a class="firn-internal" href="https://exp2exp.github.io/20201003205523-potential_products">POTENTIAL PRODUCTS</a></p></li></ul></section></div></div></div><div><hr /><div class="backlinks"><h4>Backlinks to this document:</h4><ul class="firn-backlinks"><li class="firn-backlink"><a href="https://exp2exp.github.io/index">index</a></li><li class="firn-backlink"><a href="https://exp2exp.github.io/20200905125342-emacs_hyper_notebook">Emacs Hyper Notebook</a></li></ul></div></div></article></main></body></html>